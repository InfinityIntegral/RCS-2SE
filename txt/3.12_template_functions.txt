Unit 3.12 - Template Programming with Functions
#define just got an upgrade

Template Programming
Suppose you want a function that does something, for example computing the cube of a number.
int cube(int n){	return (n * n * n);}
Yes, that works, but what if I want a long long instead? maybe a unsigned int? a float? a double?

Template Programming
Templates essentially allow you to have a variable type called a type parameter.
First you have to declare the type parameter.template<typename T>
then you write your function pretending that is the typeT cube(T n){	return (n * n * n);}

Template Programming
When using the function, since you used a template function which has a type parameter, you must specify it.
cube<int>(2); ← gives 8, workscube<float>(0.5f); ← gives 0.125f, workscube<std::string>(“cannot lah”); ← oops…
No way C++ could let that happen… right?

Template Internals
When a template is used, the compiler actually expand out the template with what you put inside, kind of like #define.
So cube<int> actually automatically generates a copy of the cube() function with T replaced with int, which works.
If you try to use cube<std::string>, it will not compile because there is no binary operator* on strings, which the generated code try to call.

Multiple type names
Templates can have multiple type parameters.
template<typename T1, typename T2>T1 cast(T2 x){	return static_cast<T1>(x);}
Just make sure they are in the correct order when you use it.

Multiple type names
Similar to when there was only 1 type parameter, you must specify what the type names actually are when using a template function with multiple type parameters.
float f = cast<float, int>(1); ← gives 1.0f, works

non type name templates
Since templates is just copy pasting, you can have things other than type names as parameters.
template<int N>int getNumber(){	return N; ← N is just a int here}
getNumber<26>(); ← gives 26
